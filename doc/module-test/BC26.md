# NB-IoT 模块 BC26 测试

## 硬件

注意供电是 5 V（请参阅文档）。经测试 3.3 V 也可以。

## 命令格式

### 基础类和扩展类命令

基础类叫作 `AT`，扩展类叫作 `AT+`。

扩展类分为：

1. 测试命令。查询参数支持的值的列表。例如：

   ```
   AT+CGMI=?
   ```

2. 查询命令。查询参数设置值（必须有状态才存在查询命令）。例如：

   ```
   AT+IPR?
   ```

3. 设置命令。设置参数（必须可以设置参数才存在设置命令）。例如：

   ```
   AT+IPR=9600
   ```

4. 执行命令。例如：

   ```
   AT+CGMR
   ```

### 保存至 NVRAM

某些指令支持将参数保存至 NVRAM（非易失性存储器）。方法是在后面加上 `&W`。例如：

```
ATE0&W
```

要将全部可以存的参数都保存至 NVRAM，写：

```
AT&W0
```

0 表示配置文件编号。

### 错误信息

显示详细错误信息。

```
AT+CMEE=2
```

## 初始化

### 1. 检查正常通信

> 模块默认处于自适应波特率模式。模块上电后，MCU 必须连续发送 AT 命令以便和模块进行波特率同步，直至返回 OK。同步成功后，MCU 可以发送 `AT+IPR=<rate>` 命令配置后续通信的波特率。若未指定波特率，则应在下次重启时重新同步。    

使用自适应波特率模式，波特率 9600。

伪代码：

```c++
while (true)
{
	send("AT\r\n");
	sleep_for(300ms); // 最大响应时间都是 300 ms。
	if (get_reply().find("OK") != npos) // 期望得到 OK，用找子串的方式搜索。
        break;
}
```

如果一直初始化失败，直接使系统崩溃（设定一个最大失败次数）。正常情况下不应该一直初始化失败。

### 2. 关闭回显

回显的意思是把命令再打印一遍，这影响了我们对有用的反馈的判断，应当关闭。

伪代码：

```C++
send("ATE0\r\n"); // OK。
sleep_for(300ms);
```

### 3. 关闭连接（目前不做）

见参考代码，在初始化时先关闭了连接。

伪代码：

```c++
send("AT+QMTDISC=0\r\n"); // OK。后面还有一些东西，但没用。
sleep_for(300ms);
```

> 当客户端请求断开与 MQTT 服务器的连接时使用该命令。客户端发送 DISCONNECT 消息到服务器表示即将与服务器断开 TCP/IP 连接。  

伪代码：

```c++
send("AT+QMTCLOSE=0\r\n"); // OK。后面还有一些东西，但没用。
sleep_for(300ms);
```

> 该命令用来关闭 MQTT 客户端网络。  

**实验发现，实际上在初始化时这么做会得到 `ERROR`。**所以这里先只像参考代码一样调用，不检查 `OK`。

**观察后面的调用，发现这里在逻辑上不对，所以这一段先不做。**

### 4. 设置功能模式

见参考代码，目前先将功能设置为全功能。**之后应尽可能减少功能模式，以减少功耗，目前遵循参考代码。**

伪代码：

```c++
send("AT+CFUN=1\r\n"); // OK。
sleep_for(300ms); // 见说明 1。
```

默认该设置立即生效，不保存到 NVRAM 中，所以后面不加可选参数 `rst`。

说明：

1. 文档说最大响应时间是 85 秒。但考虑到目前是初始化，并且参考代码中也只等了 300 ms，所以这里我们也只等待 300 ms。
2. [搜索可得](https://bbs.huaweicloud.com/forum/forum.php?mod=redirect&goto=findpost&ptid=70603&pid=304104)，如果查询 `AT+CFUN?` 能够得到 `1`，就说明已经识别到卡了。**注意卡不要插反了**（见[本帖](https://bbs.csdn.net/topics/603797277)），插反了也能得到 1，但后面的操作将失败。

### 5. 查询卡号

获得国际移动用户识别码，是不带双引号的字符串。

伪代码：

```c++
send("AT+CIMI\r\n"); // 卡号。OK。
sleep_for(300ms);
```

说明：

1. 找到卡号说明卡存在，否则经实验会得到 `ERROR`，**卡插反了也会得到 `ERROR`**。
2. 参考代码中使用了一个 `while` 循环反复调用，暂不清楚为什么要这样，所以**目前不用 `while`**。

### 6. 激活

说明：

1. 即使不主动调用，经实验也激活了，所以**目前的策略是先不做这一步，直接检查下一步**。如果遇到了下一步失败的情况再补充这一步。

### 7. 查询激活状态

查询激活状态，激活了就说明连上基站了。

伪代码：

```c++
send("AT+CGATT?\r\n"); // +CGATT: 1。OK。
sleep_for(300ms);
```

说明：

1. 参考代码中使用了一个 `while` 循环反复调用，可能是等待前面的激活步骤。**目前先不循环，因为假设已经连上了**。如果遇到了失败的情况再补充**上一步和这一步的循环**。

### 8. 获取信号质量

如果信号正常，就说明初始化彻底完成。

伪代码：

```c++
send("AT+CESQ\r\n"); // +CESQ: 20,0,255,255,28,45。OK。
sleep_for(300ms);
auto params = parse_reply();
if (params[0] == 0 || params[0] == 99) // 信号很差或者状态未知。
    fail();
```

说明：

1. 参阅 Mbed 的 AT 命令解析器。
2. 考虑到实际上有可能网不好，之后设计程序需要考虑重新配置。



## Socket连接和TCP通信

上述的初始化命令完成后就可以进行TCP通信的相关准备，实际上，在单独对模块测试时，由于波特率自适应，其实并不需要做其他预先的准备活动。

### 1. 打开Socket

```
AT+QIOPEN=1,0,"TCP","39.108.104.19",12345
```

可能需要改动的参数是后两个，为服务器IP和端口。在项目中并不需要进行改动。

第二个0为自定义的connect id，模块的TCP示例代码里直接指定为0号。项目中是单连接，故我们也定为0号即可。

### 2. 关闭Socket

```
AT+QICLOSE=0
```

关闭指定id的socket connection

### 3. 发送消息

```
AT+QISEND=0,4,"test"
```

第一个固定参数为connect id，项目中为单连接，故指定为0号。

针对每一次发送的字符串，需要传入两个变参数：

1. length，整型，为data的长度。
2. data，字符串，要发送的字符串。出于调试方便，可以直接采用ASCII码。

### 4. 接收消息

```
AT+QIRD=0,20
```

BC26的TCP连接有一个读缓冲区。从TCP server发送来的字符流会先存入这个读缓冲区，等待其读出。

第一个参数为connect ID。

第二个参数为读取缓冲区的长度。

### 5. 查询状态

BC26给出如下AT命令查询连接状况：

```
AT+QISTATE?
```

然而，这条指令只能查询是否有连接，并不能自动识别超时而被reset的过期TCP连接，实现有效的重连。所以这条指令的意义并不大，需要我们单独设计连接的心跳检测。

在项目中硬件同作为转发器的TCP server之间有两种功能连接：

1. 上传位置信息：上传前检测TCP连接是否过期reset（即上传特定指令看是否有反馈）。如果无心跳，则断开连接，重连，随后再上传。

2. 检查是否被呼叫：每秒检查一次缓冲区，看服务器是否通知其正在被呼叫。每五秒检查一次服务器心跳。如果无心跳，断开连接，重连。（同时，服务器每收到重连请求时，如果当前正在被呼叫，服务器再发送一次，说明其正在被呼叫）

   

